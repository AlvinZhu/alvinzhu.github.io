---
layout: post
mathjax: true
category: deep_learning
title: R-CNN
tags: r-cnn deep_learning object_detection
author: Alvin Zhu
date: 2017-10-09
---

* content
{:toc}

R-CNN全文翻译。





# R-CNN

# 摘要

在典型的PASCAL VOC数据集上测量的对象检测性能在过去几年中已经稳定下来。最好的方法是复杂的系统，通常将多个低级图像特征与高级语境相结合。在本文中，我们提出了一种简单可扩展的检测算法，相对于2012年VOC的先前最佳结果，平均精度（mAP）提高了30％以上，达到53.3％的mAP。我们的方法结合了两个关键的改进：（1）可以将大容量卷积神经网络（CNN）应用于自下而上的区域提案，以便定位和分割对象。（2）当标记的训练数据稀缺时，对辅助任务进行训练，然后进行域特定的微调，可以显着提升性能。由于我们将区域提案与CNN相结合，所以我们称之为我们的方法R-CNN：具有CNN特征的区域。我们还将R-CNN与OverFeat进行比较，OverFeat是最近提出的基于类似CNN架构的滑动窗口检测器。我们发现R-CNN在20类的ILSVRC2013检测数据集上大幅超越OverFeat。完整系统的源代码在[http://www.cs.berkeley.edu/\~rbg/rcnn](http://www.cs.berkeley.edu/\~rbg/rcnn)。

## 简介

特征很重要。各种视觉识别任务的过去的十年取得了很大的进步，这取决于SIFT[^29]和HOG[^7]的使用。但是如果我们观察典型的视觉识别任务的性能，如PASCAL VOC对象检测[^15]，会发现2010-2012年进展缓慢，仅通过组合不同模型和使用已有方法的变体来获得很小的改进。

SIFT和HOG是阻滞方向直方图，一种可以大致与V1中的复合细胞，灵长类动物视觉途径中的第一皮质区域相关联的表示。但是我们也知道识别发生在后续的几个阶段，这表明可能存在层次化，多阶段的计算特征的过程，这些过程对于视觉识别更为有用。

Fukushima的“神经认知机”[^19]是一种受生物学启发的分层和偏移不变的模式识别模型，这只是一个早期的尝试。但是，神经认知机缺乏监督训练算法。卷积神经网络（CNN）是一类扩展神经认知机的模型，建立在Rumelhart等[^33] LeCun等[^26]提出的通过反向传播进行的随机梯度下降的基础之上。

CNN在20世纪90年代有广泛的使用（例如[^27]），但是随着支持向量机的兴起，CNN已经逐渐淡出了公众视野。 2012年，Krizhevsky等[^25]通过在ImageNet大型视觉识别挑战（ILSVRC）上显示出更高的图像分类准确度，重新唤起了人们对CNN的兴趣[^9] [^10]。他们的成功是通过使用大型CNN训练120万张带标记图像，以及对LeCun的CNN（例如，max(x，0)非线性整流和“Dropout”正规化）的一些改进。

ImageNet结果的重要性在ILSVRC 2012研讨会期间大有争议。中心问题可以归结为：在多大程度上，CNN分类对ImageNet的分类结果可以泛化为PASCAL VOC挑战的目标检测结果？

我们通过弥合图像分类和对象检测之间的差距来回答这个问题。本文首先提出，与基于更简单的HOG类特征的系统相比，CNN可以显著提高PASCAL VOC的目标检测性能。为了实现这一结果，我们主要关注两个问题：使用深度网络定位目标，并只使用少量注带标记的检测数据训练高容量模型。

与图像分类不同，检测需要在图像中定位（可能是许多）目标。一种方法将定位作为回归问题。然而，Szegedy等人与我们并行的工作[^38]，表明这种策略在实践中可能不会很好（他们在VOC 2007年的mAP为30.5％，而我们的方法达到了58.5％）。另一种方法是构建一个滑动窗口检测器。 CNN已经以这种方式被使用了至少二十年，通常是在受限物体上，如面部[^32] [^40]和行人[^35]。为了保持高空间分辨率，这些CNN通常只有两个卷积和池化层。我们也考虑了采用滑动窗口方法。然而，在我们的网络中，具有五个卷积层的单元在输入图像中具有非常大的接收场（$195 \times 195$像素）和步进（$32 \times 32$像素），这使得在滑动窗口内的精确定位成为开放的技术挑战。

相反，我们通过在“识别使用区域”范式[^21]中操作来解决CNN的定位问题，这已经成功实现了目标检测[^39]和语义分割[^5]。在测试时间，我们的方法为输入图像生成大约2000个类别无关的区域提案，使用CNN从每个提案中提取固定长度的特征向量，然后对每个区域进行类别特定的线性SVM分类。我们使用简单的技术（图像仿射变换）来计算每个区域提案的固定大小的CNN输入，而不管区域的形状。如下图（图1）所示：（对象检测系统概述。我们的系统（1）输入一张图像，（2）提取约2000个自下而上区域提案，（3）使用大卷积神经网络（CNN）计算每个提案的特征，然后（4）使用类别特定的线性SVM。 R-CNN在PASCAL VOC 2010中实现了53.7％的平均精度（mAP）。相较之下，[^39]使用了相同的区域提案，但是使用了空间金字塔和视像单词方法，达到了35.1％的mAP。主流的可变部件模型为33.4％。在200类的ILSVRC2013检测数据集上，R-CNN的mAP为31.4％，超过OverFeat很多[^34]，先前最佳结果为24.3％。）

![Figure 1](/assets/2017-10-09-r-cnn/figure1.png)

由于我们的系统将区域提案与CNN相结合，所以我们将方法命名为R-CNN：具有CNN特征的区域。

在本文的更新版本中，我们通过在200类ILSVRC2013检测数据集上运行R-CNN，提供R-CNN和最近提出的OverFeat[^34]检测系统的比较。 OverFeat使用滑动窗口CNN进行检测，是目前在ILSVRC2013检测中性能最好的方法。我们的R-CNN明显优于OverFeat，mAP为31.4％，而OverFeat是24.3％。

检测面临的第二个挑战是带标记的数据很少，目前可用的数量不足以训练大型CNN。这个问题的常规解决方案是使用无监督的预训练，然后进行辅助微调（见[^35]）。本文的第二个主要贡献是在大型辅助数据集(ILSVRC)上进行监督预训练，然后对小数据集(PASCAL)进行域特定的微调，这是在数据稀缺时训练高容量CNN模型的有效范例。在我们的实验中，微调将检测的mAP性能提高了8个百分点。微调后，我们的系统在VOC 2010上实现了54％的mAP，而高度优化的基于HOG的可变部件模型(DPM)为33％[^17] [^20]。Donahue等人同时进行的工作[^12]表明可以使用Krizhevsky的CNN（无需微调）作为黑盒特征提取器，在多个识别任务（包括场景分类，细粒度子分类和域适配）中表现出色。

我们的系统也很有效率。唯一的类特定计算是相当小的矩阵向量乘积和贪心非极大值抑制。这种计算属性来自于所有样本共享的特征，并且比以前使用的区域特征维度还低两个数量级（参见[^39]）。

了解我们的方法的失败模式对于改进它也是至关重要的，因此我们给出了由Hoiem等人[^23]提出的的检测分析工具的结果。 作为这一分析的中间后果，我们证明了一种简单的边界回归方法显著地减少了定位误差，这是主要的误差模式。

在发掘技术细节之前，我们注意到，由于R-CNN在区域上运行，将其扩展到语义分割的任务是很自然的。经过少量的修改，我们也在PASCAL VOC分割任务中取得了有竞争力的成果，VOC 2011测试集的平均分割精度为47.9％。

## 用R-CNN进行目标检测

我们的目标检测系统由三个模块组成。第一个生成类别无关区域提案。这些提案定义了可用于我们的检测器的候选检测集。第二个模块是从每个区域提取固定长度特征向量的大型卷积神经网络。第三个模块是一组特定类别的线性SVM。在本节中，我们介绍每个模块的设计思路，描述其测试时使用情况，详细介绍其参数的学习方式，并给出在PASCAL VOC 2010-12和ILSVRC2013上的检测结果。

### 模块设计

**区域提案。**各种最近的论文提供了生成类别无关区域提案的方法。例子包括：对象性[^1]，选择性搜索[^39]，类别无关对象提议[^14]，约束参数最小化(CPMC)[^5]，多尺度组合分组[^3]和Cireşan等提出的[^6]，通过将CNN应用于特定间隔的方块来检测有丝分裂细胞，这是区域提案的特殊情况。具体的区域提案方法对于R-CNN是透明的，但我们使用选择性搜索以便于与先前检测工作的对照比较（例如[^39] [^41]）。

**特征提取。**我们使用Krizhevsky等人[^25]提出的CNN的Caffe[^24]实现，从每个区域提案中提取4096维特征向量。将减去像素平均值的$227 \times 227$分辨率的RGB图像通过五个卷积层和两个全连接层向前传播来计算特征。可以参考[^24] [^25]以获得更多的网络架构细节。

为了计算区域提案的特征，我们必须首先将该区域中的图像数据转换为与CNN兼容的格式（其架构需要固定$227 \times 227$像素大小的输入）。在许多可能的针对任意形状区域的变换中，我们选择最简单的。不管候选区域的大小或横纵比如何，我们将整个区域不保持横纵比缩放到所需的大小。在缩放之前，我们扩大了被缩放的区域，使得在缩放后，原始区域边界到现有区域边界宽度为p像素。如下图（图2）所示：（缩放后的VOC 2007训练样本，图中使用p = 16）

![Figure 2](/assets/2017-10-09-r-cnn/figure2.png)

其它的缩放方案在[附录A](#A.目标区域提案缩放)中讨论。

### 测试

在测试时，我们对测试图像进行选择性搜索，以提取大约2000个区域提案（我们在所有实验中使用选择性搜索的“快速模式”）。然后缩放每个区域，并通过CNN向前传播，以计算特征。最后，对于每个类，我们使用针对该类训练的SVM来对每个提取的特征向量进行评分。给定图像中的所有区域的得分，我们应用贪婪非极大值抑制（每个类别独立进行），在训练时学习一个阈值，如果其与得分较高的区域的重叠部分(IoU)高于这个阈值，则丢弃这个区域。

**性能分析。**两种性质使检测效率高。首先，所有CNN参数都在所有类别中共享。其次，与其他常见方法比较，由CNN计算出的特征向量是低维度的，例如具有空间金字塔和视像单词的方法。UVA检测系统[^39]中使用的特征比我们（维度，360k对比4k）大两个数量级。

这种共享的结果是计算区域建议和特征（GPU上的13秒/图像或CPU上的53秒/图像）的时间在所有类别上进行摊销。唯一的类特定计算是特征与SVM权重和非极大值抑制之间的点积。在实践中，图像的所有点积运算都被整合为单个矩阵与矩阵的相乘。特征矩阵通常为$2000 \times 4096$，SVM权重矩阵为$4096 \times N$，其中N为类别数。

分析表明，R-CNN可以扩展到数千个类，而不需要使用如散列这样的技术。即使有10万个类，在现代多核CPU上产生的矩阵乘法只需10秒。这种效率不仅仅是使用区域提案和共享特征的结果。由于其高维度特征，UVA系统的速度将会降低两个数量级，并且需要134GB的内存来存储10万个线性预测器。而对于低维度特征而言，仅需要1.5GB内存。

将R-CNN与Dean等人最近的工作对比也是有趣的。使用DPM和散列的可扩展检测[^8]。在引入1万个干扰类的情况下，每个图像的运行时间为5分钟，其在VOC 2007上的的mAP约为16％。通过我们的方法，1万个检测器可以在CPU上运行大约一分钟，而且由于没有逼近，可以使mAP保持在59％（见[消融研究](#消融研究)）。

### 训练

**监督预训练。**我们仅通过使用图像级标记来区分性地对大型辅助数据集（ILSVRC2012分类）进行CNN预训练（此数据没有检测框标记）。使用开源的Caffe CNN库进行预训练[^24]。简而言之，我们的CNN几乎符合Krizhevsky等人的论文中[^25]的表现，ILSVRC2012分类验证集获得的top-1错误率高出2.2个百分点。这种差异是由于训练过程中的简化造成的。

**域特定的微调。**为了使CNN适应新任务（检测）和新域（缩放的提案窗口），我们仅使用缩放后的区域提案继续进行CNN参数的随机梯度下降(SGD)训练。除了用随机初始化的(N + 1)路分类层（其中N是类别数，加1为背景）替换CNN的ImageNet特有的1000路分类层，CNN架构不变。对于VOC，N = 20，对于ILSVRC2013，N = 200。我们将所有区域提案与检测框真值IoU ≥0.5的区域作为正样本，其余的作为负样本。我们以0.001（初始学习率的1/10）的学习率开始SGD，这样可以在不破坏初始化的情况下进行微调。在每个SGD迭代中，我们统一采样32个正样本（在所有类别中）和96个负样本，以构建大小为128的小批量。将采样的正样本较少是因为它们与背景相比非常罕见。

**目标类别分类器。**考虑训练二分类器来检测汽车。很明显，紧紧围绕汽车的图像区域应该是一个正样本子，一个与汽车无关的背景区域应该是一个负样本。较不清楚的是如何标注部分重叠汽车的区域。我们用IoU重叠阈值来解决这个问题，在这个阈值以下的区域被定义为负样本。重叠阈值0.3是通过在验证集上尝试了$\{0,0.1,...,0.5\}$的不同阈值选择出来的。我们发现选择这个阈值是很重要的。将其设置为0.5，如[^9]，mAP会降低5个点。同样，将其设置为0会将mAP降低4个点。正样本被简单地定义为每个类的检测框真值。

一旦提取了特征并应用了训练标签，我们就可以优化每类线性SVM。由于训练数据太大内存不够，我们采用标准的难分样本挖掘方法[^17] [^37]。难分样本挖掘可以快速收敛，实际上所有图像遍历一边，mAP就停止增长了。

在[附录B](#B.正负样本和Softmax)中，我们将讨论为什么在微调与SVM训练中，正样本和负样本的数量不同。我们还讨论了涉及训练检测SVM的权衡，而不是简单地使用微调CNN的最终softmax层的输出。

### PASCAL VOC 2010-12上的结果

根据PASCAL VOC最佳实践[^15]，我们在VOC 2007数据集上验证了所有设计和超参数（见[消融研究](#消融研究)）。对于VOC 2010-12数据集的最终结果，我们对VOC 2012 train上对CNN进行了微调，并在VOC 2012 trainval上优化检测SVM。我们将测试结果提交给评估服务器，对于两种主要算法变体（带有和不带有检测框回归）的每一种，都只提交一次。

如下表（表1）所示：（VOC 2010测试的平均检测精度（％）。 R-CNN与UVA和Regionlets最相似，因为所有方法都使用选择性搜索区域提案。检测框回归（BB）在[附录C](#C.检测框回归)中描述。在本文发布时，SegDPM是PASCAL VOC排行榜中表现最好的方法。 †DPM和SegDPM使用其他方法未使用的上下文重排。）

![Table 1](/assets/2017-10-09-r-cnn/table1.png)

我们与其它四种很优秀的方法进行了比较，包括SegDPM[^18]，它将DPM检测器与语义分割系统的输出相结合[^4]，并使用了上下文重排。最具可比性的是Uijlings等人的UVA系统[^39]，因为我们的系统使用相同的区域提案算法。为了对区域进行分类，他们的方法构建了一个四级空间金字塔，并用密集采样的SIFT(（扩展对准SIFT和RGB-SIFT描述符，每个矢量用4000字的码本量化），使用直方图交叉核心SVM进行分类。与其多特征非线性内核SVM方法相比，我们将mAP从35.1％提高到了53.7％，同时也快得多（见[测试](#测试)）。我们的方法在VOC 2011/12测试中实现了接近的性能（53.3％的mAP）。

### ILSVRC2013检测结果

我们使用与PASCAL VOC相同的系统超参数，在200类的ILSVRC2013检测数据集上运行R-CNN。我们遵循相同的原则，仅提交测试结果给ILSVRC2013评估服务器两次，一次有检测框回归，一次没有。

![Figure 3](/assets/2017-10-09-r-cnn/figure3.png)

上图（图3）比较了R-CNN与ILSVRC 2013竞赛中的结果以及竞赛后提交的OverFeat结果[^34]。 R-CNN达到了31.4％的mAP，远超过OverFeat的24.3％的第二好成绩。为了说明不同类别的AP分布情况，还提供了箱子图。

下表（表8）中列出了每个类的AP。

![Table 8](/assets/2017-10-09-r-cnn/table8.png)

大多数方法（OverFeat，NEC-MU，UvA-Euvision ，Toronto A和UIUC-IFP）使用卷积神经网络，表明CNN使用方法的差异可以导致结果有很大的差别。

在[ILSVRC2013检测数据集](#ILSVRC2013检测数据集)中，我们概述了ILSVRC2013检测数据集，并提供了在运行R-CNN时详细配置信息。

## 可视化，消融和错误模式

### 可视化学习到的特征

第一层卷积核可以直观可视化，易于理解[^25]。它们捕获定向边缘和相对颜色。了解后续层次更具挑战性。 Zeiler和Fergus在[^42]中提出了一种有视觉吸引力的反卷积方法。我们提出一个简单（和补充）非参数方法，直接显示网络学到的内容。

这个想法是在网络中列出一个特定的单元（特征），并将其用作它自己的目标检测器。也就是说，我们在大量的区域提案（约1000万）中计算这个单元的激活，将提案按激活从大到小排序，然后执行非极大值抑制，然后显示激活最大的提案。通过准确显示它激活了哪些输入，我们的方法让所选单元“自己说话”。我们避免平均，以看到不同的视觉模式，并深入了解这个单元计算的不变性。

我们可以看到来自$pool_5$的单元，这是网络第五，也是最终卷积层的最大池化输出。$pool_5$的特征图维度是$6 \times 6 \times 256 = 9216$。忽略边界效应，每个$pool_5$单元在原始$227 \times 227$像素输入中具有$195 \times 195$像素的感受野。位于中央的$pool_5$单元具有几乎全局的视野，而靠近边缘的则有一个较小的裁剪的视野。

![Figure 4](/assets/2017-10-09-r-cnn/figure4.png)

如上图（图4，六个$pool_5$单元的激活最大的区域。感受野和激活值以白色绘制。某些单元与概念对齐，例如人（第1行）或文本（第4行）。其它单元捕获纹理和材料属性，如点阵列（第2行）和镜面反射（第6行）。）中的每一行都显示了在VOC 2007 trainval上进行微调的CNN中的$pool_5$单元的前16个最大激活的区域，包括256个功能独特的单元中有6个（更多参见[附录D](#D.额外的特征可视化)）。选择这些单位以显示网络学习的有代表性的样本。在第二行，我们看到一个在狗脸和点阵列上触发的单元。与第三行对应的单元是红色斑点检测器。还有用于人脸和更抽象图案的检测器，例如文本和具有窗口的三角形结构。网络似乎学习了一种将少量类别调谐特征与形状，纹理，颜色和材质属性的分布式表示相结合的表示。随后的完全连接的层$fc_6$具有对这些丰富特征的大量组合进行建模的能力。

### 消融研究

**逐层分析性能，没有微调。**为了了解哪些层对于检测性能至关重要，我们分析了CNN最后三层在VOC 2007数据集上的结果。[上一节](#可视化学习到的特征)简要描述了$pool_5$。最后两层总结如下。

层$fc_6$完全连接到$pool_5$。为了计算特征，它将$pool_5$的特征图乘以一个$4096 \times 9216$的权重矩阵（重构为9216维向量），然后加上一个偏置向量。最后应用ReLU线性整流。

层$fc_7$是网络的最后一层。这是通过将由$fc_6$计算的特征乘以4096×4096权重矩阵来实现的，并且类似地加上了偏置向量并应用ReLU线性整流。

![Table 2](/assets/2017-10-09-r-cnn/table2.png)

我们首先来看看没有在PASCAL上进行微调的CNN的结果，即所有的CNN参数仅在ILSVRC 2012上进行了预训练。逐层分析性能（如上表，表2第1-3行）显示，$fc_7$的特征总体上差于$fc_6$的特征。这意味着可以删除CNN参数的29％或约1680万，而不会降低mAP。更令人惊讶的是，即使使用仅6％的CNN参数来计算$pool_5$特征，除去$fc_7$和$fc_6$也产生相当好的结果。 CNN的大部分表达能力来自其卷积层，而不是来自于更密集的全连接层。这一发现表明通过仅使用CNN的卷积层来计算任意大小图像的类似HOG意义上的密集特征图的潜在实用性。这种表示方式可以在$pool_5$特征之上实现包括DPM在内的滑动窗口检测器。

**逐层分析性能，微调。**现在我们来看看在PASCAL上进行微调的CNN的结果。改善情况引人注目（表2第4-6行）：微调使mAP提高8.0个百分点至54.2％。对于$fc_6$和$fc_7$，微调的提升比对$pool_5$大得多，这表明从ImageNet中学习的pool 5特性是一般性的，并且大多数改进是从学习域特定的非线性分类器获得的。

**与近期特征学习方法的比较。**近期在PAS-CAL VOC检测中已经开始尝试了一些特征学习方法。我们来看两种最新的基于DPM模型的方法。作为参考，我们还包括基于标准HOG的DPM的结果[^20]。

第一个DPM特征学习方法，DPM ST[^28]，使用“草图表征”概率直方图增强了HOG特征。直观地，草图表征是通过图像片中心的轮廓的紧密分布。草图表征概率在每个像素处被随机森林计算，该森林经过训练，将35 x 35像素的图像片分类为150个草图表征或背景之一。

第二种方法，DPM HSC[^31]，使用稀疏码直方图(HSC)替代HOG。为了计算HSC，使用100个7 x 7像素（灰度）元素的学习词典，在每个像素处求解稀疏代码激活。所得到的激活以三种方式整流（全部和两个半波），空间合并，单位L2归一化，和功率变换$(x ← sign(x)\vert x \vert ^α)$。

所有R-CNN变体的都优于三个DPM基线（表2第8-10行），包括使用特征学习的两个。与仅使用HOG特征的最新版本的DPM相比，我们的mAP提高了20个百分点以上：54.2％对比33.7％，相对改进61％。HOG和草图表征的组合与单独的HOG相比mAP提高2.5个点，而HSC在HOG上mAP提高了4个点（使用内部私有的DPM基线进行比较，两者都使用非公开实现的DPM，低于开源版本[^20]）。这些方法的mAP分别达到29.1％和34.3％。

### 网络架构

本文的大多数结果使用了Krizhevsky等人的网络架构[^25]。然而，我们发现架构的选择对R-CNN检测性能有很大的影响。如下表（表3）中所示：（两种不同CNN架构在VOC 2007检测测试的平均精度（％）。前两行是使用Krizhevsky等人的架构（T-Net）的表2的结果。第三和第四行使用Simonyan和Zisserman（O-Net）最近提出的16层架构[^43]。）

![Table 3](/assets/2017-10-09-r-cnn/table3.png)

我们使用Simonyan和Zisserman最近提出的16层深度网络[^43]并给出了VOC 2007测试的结果。该网络是2014年ILSVRC分类挑战中表现最好的网络之一。网络具有由13层$3 \times 3$卷积核组成的均匀结构，其中散布五个最大池化层，最后接三个全连接层。我们将该网络称为“O-Net”即牛津网络，基准称为“T-Net”即多伦多网络。

要在R-CNN中使用O-Net，我们从Caffe模型库下载了预训练的VGG\_ILSVRC\_16\_layers模型（https://github.com/BVLC/caffe/wiki/Model-Zoo）。然后我们使用与T-Net一样的方法对网络进行了微调。唯一的区别是根据需要使用较小的批量（24个），以适应GPU内存。表3中的结果显示，具有O-Net的R- CNN基本上优于T-网络的R-CNN，将mAP从58.5％提高到66.0％。然而，在计算时间方面存在相当大的缺陷，O-Net的前进速度比T-Net长约7倍。

### 检测错误分析

为了揭示我们的方法的错误模式，我们应用了Hoiem等人的优秀检测分析工具[^23]，以了解微调如何改变它们，并将我们的错误类型与DPM比较。分析工具的完整介绍超出了本文的范围，可以参考[^23]了解更多的细节（如“标准化AP”）。千言万语不如一张图，我们在下图（图5和图6）中讨论。

![Figure 5](/assets/2017-10-09-r-cnn/figure5.png)

最多的假阳性（FP）类型分布。每个图表显示FP类型的演变分布，按照FP数量降序排列。FP分为4种类型：Loc（定位精度差，检测框与真值的IoU在0.1到0.5之间或重复的检测）。Sim（与相似类别混淆）。Oth（与不相似的类别混淆）。BG（检测框标在了背景上）。与DPM（参见[^23]）相比，我们的Loc显著增加，而不是Oth和BG，表明CNN特征比HOG更具区分度。Loc增加的原因可能是我们使用自下而上的区域提案可能产生松散的定位位置，以及CNN进行全图像分类的预训练模型所获得的位置不变性。第三列显示了我们的简单边界回归方法如何修复许多Loc。

![Figure 6](/assets/2017-10-09-r-cnn/figure6.png)

对目标特点的敏感度。每个图显示六个不同目标特点（遮挡，截断，边界区域，纵横比，视角，局部可视性）内最高和最低性能的子集的平均值（跨类别）归一化AP（见[^23]）。我们展示了我们的方法（R-CNN）有或没有微调（FT）和边界回归（BB）以及DPM voc-release5的图。总体而言，微调并不会降低敏感度（最大和最小值之间的差异），而且对于几乎所有的特点，都能极大地提高最高和最低性能的子集的性能。这表明微调不仅仅是简单地提高纵横比和边界区域的最低性能子集的性能（在分析之前，基于我们如何缩放网络输入而推测）。相反，微调可以改善所有特点的鲁棒性，包括遮挡，截断，视角和局部可视性。

### 检测框回归

基于错误分析，我们实现了一种简单的方法来减少定位错误。受DPM中使用的检测框回归的启发[^17]，我们训练一个线性回归模型使用在区域提案上提取的$pool_5$特征来预测一个新的检测框。完整的细节在[附录C](#C.检测框回归)中给出。表1，表2和图5中的结果表明，这种简单的方法解决了大量的定位错误，将mAP提高了3到4个点。

### 定性结果

ILSVRC2013的定性检测结果如下图（图8和图9）所示：

![Figure 8](/assets/2017-10-09-r-cnn/figure8.png)

在$val_2$上达到31.0％mAP的配置的检测结果示例。每个图像都是随机抽样的（这些都没有刻意挑选）。显示精度大于0.5的所有检测，并标记了预测的类别和精度。可以放大以看清楚

![Figure9](/assets/2017-10-09-r-cnn/figure9.png)

更多示例。详见图8说明。

更稳定的结果如下图（图10和图11）所示：

![Figure10](/assets/2017-10-09-r-cnn/figure10.png)

![Figure11](/assets/2017-10-09-r-cnn/figure11.png)

这些示例是经过挑选的。我们选择这些图像是因为它们包含有趣的的结果。

## ILSVRC2013检测数据集

在[用R-CNN进行目标检测](#用R-CNN进行目标检测)中，我们介绍了ILSVRC2013检测数据集的结果。该数据集与PASCAL VOC不太一致，需要选择如何使用它。由于这些选择不是显而易见的，我们将在这一节中介绍这些选择。

### 数据集概述

ILSVRC2013检测数据集分为三组：训练(395,918)，验证(20,121)和测试(40,152)，其中每组的图像数目在括号中。验证和测试集是从相同的图像分布中划分的。这些图像与PASCAL VOC图像中的场景和复杂性（目标数量，杂波量，姿态变异性等）类似。验证和测试集是详尽标注的，这意味着在每个图像中，来自所有200个类的所有实例都被标注为边界框。相比之下，训练集来自ILSVRC2013分类图像。这些图像具有更多的可变复杂性，并且倾向于是单个位于图像中心的目标的图像。与验证和测试集不同，训练集（由于它们的数量很多）没有详尽标注。在任何给定的训练图像中，200个类别的实例可能被标注也可能不被标注。除了这些图像集，每个类都有一组额外的负样本。负样本经过人工检查以确认它们不包含任何相关类的实例。本文没有使用负样本。有关如何收集和标注ILSVRC的更多信息可以在[^11] [^36]中找到。

这些数据集的分组的性质为训练R-CNN提供了许多选择。训练图像不能用于难负样本重训练，因为标注不是很好。负样本来自哪里？此外，训练图像具有不同于验证和训练集的分布。是否应该使用训练图像，如果是，在什么程度上？虽然我们还没有彻底评估大量的选择，但是我们根据以往的经验，提出了一个最明显的路径。

我们的总体策略是严重依赖验证集，并使用一些训练图像作为一个辅助正样本来源。为了使用验证集进行训练和验证，我们将其分成大小大致相等的“$val_1$”和“$val_2$”集合。由于某些类在val中的数量非常少（最小的只有31个，连110个的一半都不到），所以产生一个近似类间均衡的划分是很重要的。为此，产生了大量的候选分割，并选择了最大相对类间不平衡的最小值（相对不平衡度被定义为$\vert a - b \vert / (a + b)$，其中a和b是两个集合各自的类计数）。每个候选分裂是通过使用其类计数作为特征聚类的验证集图像来生成的，然后是是一个可以改善划分平衡度的随机局部搜索。这里使用的特定划分具有约11％的最大相对类间不平衡和4％的中值相对类间不平衡。$val_1$/$val_2$划分和用于生产它们的代码将被公开提供，以允许其他研究人员将他们的方法与在本文中使用的验证集划分方法进行比较。

### 区域提案

我们遵循用于PASCAL检测的区域提案方法。选择性搜索[^39]在$val_1$，$val_2$中的每个图像上以“快速模式”运行，并进行测试（但不是在训练图像上）。需要一个小的修改来处理选择性搜索不是尺度不变的，所以需要产生的区域数量取决于图像分辨率。 ILSVRC的图像尺寸范围从非常小到少量几百万像素的图像，因此我们在运行选择性搜索之前，将每个图像的大小调整为固定的宽度（500像素）。在验证集上，选择性搜索在每个图像上平均有2403个区域提案，检测框真值（以0.5 IoU阈值）的召回率91.6％。这一召回率明显低于PASCAL的约98％，表明该区域提案阶段有明显的改善空间。

### 训练数据

对于训练数据，我们形成了一套图像和方框，其中包括$val_1$的所有选择性搜索和检测框真值，以及训练集中每个类别最多N个检测框真值（如果一个类别的检测框真值数少于N个，那就有多少用多少）。我们将把这个数据集称为$val_1 + train_N$。在消融研究中，我们给出了N∈{0,500,1000}的$val_2$上的mAP（见[消融实验](#消融实验)）。

R-CNN中的三个阶段需要训练数据：（1）CNN微调，（2）检测器SVM训练（3）检测框回归训练。使用与用于PASCAL的完全相同的设置，在$val_1 + train_N$上进行50k次SGD迭代以微调CNN。使用Caffe在一块NVIDIA Tesla K20上微调花了13个小时。对于SVM训练，使用来自$val_1 + train_N$的所有检测框真值作为各自类别的正样本。对来自$val_1$的5000张（大约一半）随机选择的图像的子集执行难负样本重训练。最初的实验表明，难负样本重训练仅使mAP下降了0.5个百分点，同时将SVM训练时间缩短了一半。没有从训练集中采样负样本，因为没有详尽标注。没有额外的经过确认的负样本。检测框回归器在$val_1$训练。

### 验证和评估

在将结果提交给评估服务器之前，我们使用上述训练数据验证了数据使用选择、微调和检测框回归对val 2集的影响。所有系统超参数（例如，SVM C超参数，区域缩放中使用的边界填充，NMS阈值，检测框回归超参数）固定为与PASCAL相同的值。毫无疑问，这些超参数选择中的一些对ILSVRC来说稍微不太理想，但是这项工作的目标是在没有广泛数据集调优的情况下，在ILSVRC上产生初步的R-CNN结果。在选择$val_2$上的最佳配置后，我们提交了两个结果文件到ILSVRC2013评估服务器。第一个没有检测框回归，第二个有检测框回归。对于这些提交，我们扩展了SVM和检测框回归训练集，分别使用$val + train_{1k}$和$val$。我们在$val_1 + train_{1k}$上微调CNN来避免重新运行微调和特征计算。

### 消融实验

如下表（表4）所示：（ILSVRC2013上的数据使用选择、微调和边界回归消融研究。）

![Table 4](/assets/2017-10-09-r-cnn/table4.png)

第一个观察是，$val_2$上的mAP与测试集上的mAP非常接近。这使我们有信心相信，$val_2$上的mAP是测试集性能的良好指标。第一个结果是20.9％，是在ILSVRC2012分类数据集上预训练的CNN（无微调）并允许访问$val_1$中少量训练数据的R-CNN实现（$val_1$中一半的类别，每个类有15到55个样本）。将训练集扩展到$val_1 + train_N$将性能提高到24.1％，N = 500和N = 1000之间基本上没有差异。使用仅从$val_1$的样本微调CNN可以稍微改善到26.5％，但是由于用于训练的正样本较少，可能会出现严重的过拟合。将用于微调的数据扩展到$val_1 + train_{1k}$，相当于每个类增加了100个正样本用于训练，有助于将mAP显著提高至29.7％。检测框回归将结果提高到31.0％，这与PASCAL中所观察到的收益相比较小。

### 与OverFeat的关系

R-CNN和OverFeat之间有一个有趣的关系：OverFeat可以看作（大致上）是R-CNN的一个特例。如果用一个多尺度的正方形区域的金字塔取代选择性搜索区域提案，并将每个类别的检测框回归器改变为一个单一的检测框回归函数，则两个系统将是非常相似的（训练上有一些潜在的显著差异：CNN微调、使用SVM等）。值得注意的是，OverFeat比R-CNN具有显着的速度优势：根据[^34]引用的图中显示每张图像2秒，速度约为RCNN的9倍。这种速度来自于OverFeat的滑动窗口（即区域提案）在图像级别没有缩放的事实，因此可以在重叠窗口之间轻松共享计算。通过在任意大小的输入上以卷积方式运行整个网络来实现共享。加快R-CNN的速度应该应该有很多可行的办法，未来的工作中将会考虑。

## 语义分割

区域分类是语义分割的基础，这使我们可以轻松地将R-CNN应用于PASCAL VOC分割挑战。为了便于与当前领先的语义分割系统（称为“二阶池化”的$O_2P$）[^4]的直接比较，我们在其开源框架内修改。$O_2P$使用CPMC为每个图像生成150个区域提案，然后使用支持向量回归(SVR)来预测对于每个类别的每个区域的质量。他们的方法的高性能是由于CPMC区域的高质量和强大的多种特征类型（SIFT和LBP的丰富变体）的二阶池化。我们还注意到，Farabet等[^16]最近使用CNN作为多尺度像素级分类器在几个密集场景标记数据集（不包括PAS-CAL）上取得了良好的结果。

我们遵循[^2] [^4]并扩展PASCAL分割训练集，以包含Hariharan等提供的额外注释[^22]。在VOC 2011验证集上，交叉验证我们的设计决策和超参数。最终测试结果仅提交一次。

**用于分割的CNN特征。**我们评估了在CPMC区域上计算特征的三个策略，所有这些策略都是将区域缩放为227 x 227。第一个策略（full）忽略了该区域的形状，并直接在缩放后的区域上计算CNN特征，就像我们缩放区域提案那样。然而，这些特征忽略了区域的非矩形形状。两个区域可能具有非常相似的边界框，同时具有非常小的重叠。因此，第二个策略（fg）仅在区域的前景掩码上计算CNN特征。我们用图像均值替换背景，使得背景区域在减去图像均值后为零。第三个策略（full + fg）简单地连接full和fg特征。我们的实验验证了它们的互补性。

**VOC 2011结果。**如下表（表5）所示：（在VOC 2011验证集上的平均分割精度。第一列是$O_2P$的结果，2-7列是我们在ILSVRC 2012上预训练的CNN的结果）

![Table 5](/assets/2017-10-09-r-cnn/table5.png)

每个类别的完整结果参见[附录E](#E.每个类别的分割结果)。在每种特征计算策略中，$fc_6$总是超过$fc_7$，以下讨论是指$fc_6$的特征。fg策略稍微优于full，表明掩码区域的形状提供了更强的信号，与我们的直觉相匹配。然而，full + fg的平均准确度达到47.9％，比我们的fg最佳结果高4.2％（也略胜于$O_2P$），表明full特征提供大量的信息，即使给定fg特征。值得注意的是，在full + 特征上使用一个CPU核心训练20个SVR需要花费一个小时，相比之下，在$O_2P$特征上训练需要10个多小时。

如下表（表6）所示：（在VOC 2011 测试集上的分割精度。我们与两个强大的基线做对比：“Regions and Parts”(R&P)[^2]和$O_2P$[^4]。没有微调。我们的CNN实现了优异的分割性能，超过了R&P，与$O_2P$差不多）

![Table 6](/assets/2017-10-09-r-cnn/table6.png)

我们提供了VOC 2011测试集的结果，将我们的最佳表现方法$fc_6$(full + fg)与两个强大的基线进行了比较。我们的方法在21个类别中的11个中达到了最高的分割精度，最高的分割精度为47.9％，跨类别平均（但可能与任何合理的误差范围内的$O_2P$结果有关）。微调可能会实现更好的性能。

## 结论

近年来，物体检测性能停滞不前。性能最好的系统是复杂的组合，将多个低级图像特征与来自物体检测器和场景分类器的高级语境相结合。本文提出了一种简单且可扩展的对象检测算法，相对于PASCAL VOC 2012上的前最佳结果，相对改进了30％。

我们通过两个关键的改进实现了这一效果。第一个是将大容量卷积神经网络应用于自下而上的区域提案，以便定位和分割对象。第二个是在有标记的训练数据很少的情况下训练大型CNN的方法。我们发现，通过使用大量的图像分类数据对辅助任务进行有监督的预训练，然后对数据稀缺的目标检测任务进行微调，是非常有效的。我们相信，“监督的预训练/领域特定的微调”的方法对于各种数据缺乏的视觉问题都将是非常有效的。

我们通过使用计算机视觉中的经典工具与深度学习（自下而上的区域提案和卷积神经网络）的组合达到了很好的效果。而不是仅仅依靠纯粹的科学探究。

**致谢：**该研究部分由DARPA Mind的Eye与MSEE项目支持，NSF授予了IIS-0905647，IIS-1134072和IIS-1212798，以及丰田支持的MURI N000014-10-1-0933。本研究中使用的GPU由NVIDIA公司慷慨捐赠。

## 附录

### A.目标区域提案缩放

本文中使用的卷积神经网络需要$227 \times 227$像素的固定大小输入。为了检测，我们认为目标提案是任意矩形的图像。我们评估了将目标提案转换为有效的CNN输入的两种方法。

如下图（图7）所示：

![Figure 7](/assets/2017-10-09-r-cnn/figure7.png)

第一个方法将目标提案扩充为正方形并缩放到所需大小，如图7(B)所示。这种方法还有一种变体，仅扩充为方框，扩充部分不填充图像内容，如图7(C)所示。第二种方法是将目标提案不保留横纵比的情况下缩放到所需大小，如图7(D)所示。

对于这些转换中的每一个，我们还考虑在原始目标提案四周包括附加图像内容。内容填充的量($p$)被定义为在缩放后图像中，原始目标提案周围的边界大小。图7显示了每个示例的顶行中$p = 0$像素，底行中$p = 16$像素。在所有方法中，如果矩形框超出图像边缘，超出的部分将被填充为图像均值（然后在将图像输入到CNN之前减去）。一组实验表明，采用上下文填充（$p = 16$像素）的缩放可以明显提高mAP（提高3-5个点）。显然还有更多其它可行的方案，包括使用复制而不是平均填充。对这些方案的详尽评估将作为未来的工作。

### B.正负样本和Softmax

有两个设计选择值得进一步讨论。第一个是：为什么在微调CNN和训练目标检测SVM时定义的正负样本不同？首先简要回顾下正负样本的定义，对于微调，我们将每个目标提案映射到它具有最大IoU重叠（如果有的话）的检测框真值上，如果其IoU至少为0.5，并将其标记为对应类别的正样本。剩下的提案都标记为“背景”（即所有类的负样本）。对于训练SVM，相比之下，我们只采用检测框真值作为各自类别的正样本。与某一类别所有的正样本的IoU都小于0.3的目标提案将被标记为该类别的负样本。其它（IoU超过0.3，但不是检测框真值）的提案被忽略。

从时序上讲，我们得出这些定义是因为我们一开始通过由ImageNet预先训练的CNN计算出的特征训练SVM，因此微调在这个时间点不是一个需要考虑因素。在这种情况下，我们发现，在我们评估的一组设置（包括我们现在用于微调的设置）中，我们当前使用的训练SVM的设置是最佳的。当我们开始使用微调时，我们最初使用与我们用于SVM训练的正负样本的定义相同的定义。然而，我们发现结果比使用我们当前定义的正负样本获得的结果差得多。

我们的假设是，如何定义正负样本的差异对训练结果影响不大，结果的差异主要是由微调数据有限这一事实引起的。我们目前的方案引入了许多“抖动”的样本（这些提案与检测框真值的重叠在0.5和1之间，但并不是检测框真值），这将正样本的数量增加了大约30倍。我们推测，需要使用如此大量的样本以避免在微调网络时的过拟合。然而，我们还注意到，使用这些抖动的例子可能不是最佳的，因为网络没有被微调以进行精确的定位。

这导致了第二个问题：为什么微调之后，训练SVM呢？简单地将最后一层微调网络（21路Softmax回归分类器）作为对象检测器将变得更加简洁。我们尝试了这一点，发现VOC 2007的表现从54.2％下降到了50.9％的mAP。这种性能下降可能来自几个因素的组合，包括微调中使用的正样本的定义不强调精确定位，并且softmax分类器是在随机抽样的负样本上训练的，而不是用于训练SVM的“更严格的负样本”子集。

这个结果表明，微调之后可以获得接近SVM水平的性能，而无需训练SVM。我们推测，通过一些额外的调整来微调以达到更接近的水平。如果是这样，这样可以简化和加速R-CNN训练，而不会在检测性能方面有任何损失。

### C.检测框回归

我们使用一个简单的检测框回归来提高定位性能。在使用类特定检测SVM对每个选择性搜索提案进行评分之后，我们使用类别特定的边界回归器预测新的检测框。这与在可变部件模型中使用的检测框回归相似[^17]。这两种方法之间的主要区别在于，我们使用CNN计算的特征回归，而不是使用在推测的DPM部件位置上计算的几何特征。

我们的训练算法的输入是一组$N$个训练对$\{(P^i, G^i)\}_{i=1,...,N}$，其中$P^i = (P^i_x, P^i_y, P^i_w, P^i_h)$指定提案$P^i$的边界框中心的像素坐标以及宽度和高度（以像素为单位）。注意，除非需要，下文中我们不再写出上标$i$。每个检测框真值$G$以相同的方式指定：$G = (G_x, G_y, G_w, G_h)$。我们的目标是学习将提案框$P$映射到检测框真值G的转换。

我们使用四个函数$d_x(P)$，$d_(yP)$，$d_(Pw)$和$d_h(P)$参数化这个转换。前两个指定$P$的边界框的中心的比例不变的平移，后两个指定$P$的边界框的宽度和高度的对数空间转换。在学习了这些函数后，我们可以通过应用转换将输入提案P转换成预测的检测框真值$\widehat{G}$。
$$
\widehat{G}_x = P_wd_x(P) + P_x \tag{1}
$$

$$
\widehat{G}_y = P_hd_y(P) + P_y \tag{2}
$$

$$
\widehat{G}_w = P_wexp(d_w(P)) \tag{3}
$$

$$
\widehat{G}_h = P_hexp(d_h(P)) \tag{4}
$$

每个函数$d_{\star}(P)$（$\star$表示$x,y,w,h$中的一个）都建模为提案$P$的$pool_5$特征（记为$\phi_5(P)$，对图像数据的依赖隐含的假定）的线性函数。即$d_{\star}(P) = w^T_{\star}\phi_5(P)$，其中$w_{\star}$表示模型和训练参数的一个向量，通过优化正则化最小二乘法的目标（脊回归）来学习$w_{\star}$。
$$
w_{\star} = \underset{\widehat{w}_{\star}}{argmin}\sum_i^N(t_{\star}^i - \widehat{w}_{\star}^T\phi_5(P^i))^2 + \lambda\left \| \widehat{w}_{\star} \right \|^2 \tag{5}
$$

训练对$(P, G)$的回归目标$t_{\star}$定义为：
$$
t_x = (G_x - P_x) / P_w \tag{6}
$$

$$
t_y = (G_y - P_y) / P_h \tag{7}
$$

$$
t_w = \log(G_w / P_w) \tag{8}
$$

$$
t_h = \log(G_h / P_h) \tag{9}
$$

作为标准正则化最小二乘问题，可以有效的找到封闭解。

我们在实现边界回归的过程中发现了两个微妙的问题。第一是正则化是重要的：我们基于验证集，设置$\lambda = 1000$。第二个问题是，选择使用哪些训练对$(P, G)$时必须小心。直观地说，如果$P$远离所有的检测框真值，那么将$P$转换为检测框真值G的任务就没有意义。使用像$P$这样的例子会导致一个无望的学习问题。因此，只有当提案$P$至少在一个检测框真值附近时，我们才执行学习任务。“附近”即，将$P$分配给具有最大IoU的检测框真值G（在重叠多于一个的情况下），并且仅当重叠大于阈值（基于验证集，我们使用的阈值为0.6）。所有未分配的提案都被丢弃。我们为每个目标类别执行一次，以便学习一组特定于类别的检测框回归器。

在测试时，我们对每个提案进行评分，并预测其新的检测框一次。原则上，我们可以迭代这个过程（即重新评估新预测的检测框，然后从它预测一个新的检测框，等等）。但是，我们发现迭代不会改进结果。

### D.额外的特征可视化

如下图（图12）所示：（我们展示在VOC 2007测试的大约1000万个区域中的激活最大的24个区域提案，分别最强烈地激活了20个单元。每一组以单元在6 x 6 x 256维的$pool_5$特征图中的$(y, x, channel)$位置标记。每个图像区域都用白色叠加绘制了单元感受野。激活值（我们通过除以通道中的所有单位的最大激活值进行归一化）被显示在感受野的左上角。可通过放大来看清楚。）

![Figure 12](/assets/2017-10-09-r-cnn/figure12.png)

图中显示了额外20个$pool_5$单元的可视化。对于每个单元，我们展示在VOC 2007测试的大约1000万个区域中的激活最大的24个区域提案。

每一组以单元在6 x 6 x 256维的$pool_5$特征图中的$(y, x, channel)$位置标记。在每个通道内，CNN使用相同的函数计算不同的输入，$(y, x)$位置仅改变感受野。

### E.每个类别的分割结果

如下表（表7）所示：（VOC 2011验证集上每一类的分割准确率）

![Table 7](/assets/2017-10-09-r-cnn/table7.png)

除了$O_2P$[^4]方法之外，我们还给出了我们的六种分割方法在VOC 2011 val上每个类别的分割精度。包括背景类，这些结果显示了在20个PASCAL类中哪种方法最强。

### F.跨数据集冗余分析

对辅助数据集进行训练时，一个问题是它与测试集之间可能存在冗余。由于目标检测和整图像分类的任务大不相同，使得这种交叉冗余没那么令人担忧，我们仍然进行了调查，以量化PASCAL测试集被包含在ILSVRC 2012训练和验证集中的程度。对于有兴趣使用ILSVRC 2012作为PASCAL图像分类任务的训练数据的研究人员，我们的研究结果可能是有用的。

我们对重复（和近似重复）的图像进行了两次检查。第一个测试是基于Flickr图像ID的完全匹配，它们包含在VOC 2007测试集的标注中（在后续的PASCAL测试集中这些ID有意保密）。所有PASCAL图像，以及大约一半的ILSVRC，都是从flickr.com收集的。在4952中有31个匹配（0.63％）。

第二个检查使用GIST[^30]描述符匹配，如[^13]所示，在大型（> 100万）图像集合中的近似重复图像检测中具有出色的性能。按照[^13]所述，我们计算了所有ILSVRC 2012 trainval和PASCAL 2007测试集的图像的缩放到$32 \times 32$像素版本的GIST描述符。

GIST描述符的欧几里德距离最近邻匹配找出了38个近似重复的图像（包括由flickr ID匹配发现的所有31个）。这些匹配在JPEG压缩级别和分辨率方面略有不同，裁剪程度也较小。这些研究结果表明，冗余很小，小于1％。对于VOC 2012，因为flickr ID不可用，我们仅使用GIST匹配方法。基于GIST匹配，VOC 2012测试图像中有1.5％与ILSVRC 2012匹配。 VOC 2012略高可能是由于两个数据集在时间上比VOC 2007和ILSVRC 2012更接近。

### G. 文件更新日志

本文档跟踪R-CNN的进展情况。为了帮助读者了解它随时间的变化，这里是一个描述修订版本的简短的更新日志。

**v1** 初始版本。

**v2** CVPR 2014 camera-ready版本。包括检测性能的实质性改进（1）从高学习率开始微调（0.001而不是0.0001），（2）在准备CNN输入时使用上下文填充，（3）检测框回归来修正定位错误。

**v3** ILSVRC2013检测数据集的结果，与OverFeat比较的结果被添加到了文中。

**v4** 附录B中softmax vs. SVM的结果包含一个已经修复的错误。我们感谢Sergio Guadarrama帮助确定这个问题。

**v5** 添加了使用Simonyan和Zisserman[^43]的新的16层网络架构的结果。

**参考文献：**

[^1]: B. Alexe, T. Deselaers, and V. Ferrari. Measuring the objectness of image windows. TPAMI, 2012.
[^2]: P. Arbeláez, B. Hariharan, C. Gu, S. Gupta, L. Bourdev, and J. Malik. Semantic segmentation using regions and parts. In CVPR, 2012.
[^3]: P. Arbeláez, J. Pont-Tuset, J. Barron, F. Marques, and J. Malik. Multiscale combinatorial grouping. In CVPR, 2014.
[^4]: J. Carreira, R. Caseiro, J. Batista, and C. Sminchisescu. Semantic segmentation with second-order pooling. In ECCV, 2012.
[^5]: J. Carreira and C. Sminchisescu. CPMC: Automatic object segmentation using constrained parametric min-cuts. TPAMI, 2012.
[^6]: D. Cireşan, A. Giusti, L. Gambardella, and J. Schmidhuber. Mitosis detection in breast cancer histology images with deep neural networks. In MICCAI, 2013.
[^7]: N. Dalal and B. Triggs. Histograms of oriented gradients for human detection. In CVPR, 2005.
[^8]: T. Dean, M. A. Ruzon, M. Segal, J. Shlens, S. Vijayanarasimhan, and J. Yagnik. Fast, accurate detection of 100,000 object classes on a single machine. In CVPR, 2013.
[^9]: J. Deng, A. Berg, S. Satheesh, H. Su, A. Khosla, and L. FeiFei. ImageNet Large Scale Visual Recognition Competition 2012 (ILSVRC2012). http://www.image-net.org/challenges/LSVRC/2012/.
[^10]: J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. FeiFei. ImageNet: A large-scale hierarchical image database. In CVPR, 2009.
[^11]: J. Deng, O. Russakovsky, J. Krause, M. Bernstein, A. C. Berg, and L. Fei-Fei. Scalable multi-label annotation. In CHI, 2014.
[^12]: J. Donahue, Y. Jia, O. Vinyals, J. Hoffman, N. Zhang, E. Tzeng, and T. Darrell. DeCAF: A Deep Convolutional Activation Feature for Generic Visual Recognition. In ICML, 2014.
[^13]: M. Douze, H. Jégou, H. Sandhawalia, L. Amsaleg, and C. Schmid. Evaluation of gist descriptors for web-scale image search. In Proc. of the ACM International Conference on Image and Video Retrieval, 2009.
[^14]: I. Endres and D. Hoiem. Category independent object proposals. In ECCV, 2010.
[^15]: M. Everingham, L. Van Gool, C. K. I. Williams, J. Winn, and A. Zisserman. The PASCAL Visual Object Classes (VOC) Challenge. IJCV, 2010.
[^16]: C. Farabet, C. Couprie, L. Najman, and Y. LeCun. Learning hierarchical features for scene labeling. TPAMI, 2013.
[^17]: P. Felzenszwalb, R. Girshick, D. McAllester, and D. Ramanan. Object detection with discriminatively trained part based models. TPAMI, 2010.
[^18]: S. Fidler, R. Mottaghi, A. Yuille, and R. Urtasun. Bottom-up segmentation for top-down detection. In CVPR, 2013.
[^19]: K. Fukushima. Neocognitron: A self-organizing neural network model for a mechanism of pattern recognition unaffected by shift in position. Biological cybernetics, 36(4):193–202, 1980.
[^20]: R. Girshick, P. Felzenszwalb, and D. McAllester. Discriminatively trained deformable part models, release 5. [http://www.cs.berkeley.edu/\~rbg/latent-v5/](http://www.cs.berkeley.edu/\~rbg/latent-v5/).
[^21]: C. Gu, J. J. Lim, P. Arbeláez, and J. Malik. Recognition using regions. In CVPR, 2009.
[^22]: B. Hariharan, P. Arbeláez, L. Bourdev, S. Maji, and J. Malik. Semantic contours from inverse detectors. In ICCV, 2011.
[^23]: D. Hoiem, Y. Chodpathumwan, and Q. Dai. Diagnosing error in object detectors. In ECCV. 2012.
[^24]: Y. Jia. Caffe: An open source convolutional architecture for fast feature embedding. http://caffe.berkeleyvision.org/, 2013.
[^25]: A. Krizhevsky, I. Sutskever, and G. Hinton. ImageNet classification with deep convolutional neural networks. In NIPS, 2012.
[^26]: Y. LeCun, B. Boser, J. Denker, D. Henderson, R. Howard, W. Hubbard, and L. Jackel. Backpropagation applied to handwritten zip code recognition. Neural Comp., 1989.
[^27]: Y. LeCun, L. Bottou, Y. Bengio, and P. Haffner. Gradient-based learning applied to document recognition. Proc. of the IEEE, 1998.
[^28]: J. J. Lim, C. L. Zitnick, and P. Dollár. Sketch tokens: A learned mid-level representation for contour and object detection. In CVPR, 2013.
[^29]: D. Lowe. Distinctive image features from scale-invariant keypoints. IJCV, 2004.
[^30]: A. Oliva and A. Torralba. Modeling the shape of the scene: A holistic representation of the spatial envelope. IJCV, 2001.
[^31]: X. Ren and D. Ramanan. Histograms of sparse codes for object detection. In CVPR, 2013.
[^32]: H. A. Rowley, S. Baluja, and T. Kanade. Neural network-based face detection. TPAMI, 1998.
[^33]: D. E. Rumelhart, G. E. Hinton, and R. J. Williams. Learning internal representations by error propagation. Parallel Distributed Processing, 1:318–362, 1986.
[^34]: P. Sermanet, D. Eigen, X. Zhang, M. Mathieu, R. Fergus, and Y. LeCun. OverFeat: Integrated Recognition, Localization and Detection using Convolutional Networks. In ICLR, 2014.
[^35]: P. Sermanet, K. Kavukcuoglu, S. Chintala, and Y. LeCun. Pedestrian detection with unsupervised multi-stage feature learning. In CVPR, 2013.
[^36]: H. Su, J. Deng, and L. Fei-Fei. Crowdsourcing annotations for visual object detection. In AAAI Technical Report, 4th Human Computation Workshop, 2012.
[^37]: K. Sung and T. Poggio. Example-based learning for view-based human face detection. Technical Report A.I. Memo No. 1521, Massachussets Institute of Technology, 1994.
[^38]: C. Szegedy, A. Toshev, and D. Erhan. Deep neural networks for object detection. In NIPS, 2013.
[^39]: J. Uijlings, K. van de Sande, T. Gevers, and A. Smeulders. Selective search for object recognition. IJCV, 2013.
[^40]: R. Vaillant, C. Monrocq, and Y. LeCun. Original approach for the localisation of objects in images. IEE Proc on Vision, Image, and Signal Processing, 1994.
[^41]: X. Wang, M. Yang, S. Zhu, and Y. Lin. Regionlets for generic object detection. In ICCV, 2013.
[^42]: M. Zeiler, G. Taylor, and R. Fergus. Adaptive deconvolutional networks for mid and high level feature learning. In CVPR, 2011.
[^43]: K. Simonyan and A. Zisserman. Very Deep Convolutional Networks for Large-Scale Image Recognition. arXiv preprint, arXiv:1409.1556, 2014.
